// TODO
// ----
// [x] Scaling bug => scale up the ship.
// [x] Rotate turrets with ship.
// [x] Mv force transmission from ship to bullets. => TECH DEBT
// [x] Acceleration / max speed bug.
// [x] Fix teams requirements.
// [x] Fix colliders requirements.
// [x] Turret slot redesign.
// [x] Extract player controller to separate keyboard controller.
// [x] Create player rotative mouse controller.
// [ ] Create AI controllers.
// [ ] Implement relative camera.
// [ ] Constrain angle to arc > 180deg bug.

const Settings = {
	ShipController: {
		Keyboard: {
			Forward: "KeyW",
			Backward: "KeyS",
			RotateLeft: "KeyA",
			RotateRight: "KeyD",
			Left: "KeyQ",
			Right: "KeyE"
		},
		RotatingMouse: {
			Forward: "KeyW",
			Backward: "KeyS",
			Left: "KeyA",
			Right: "KeyD"
		}
	},
	DirectFire: "MouseLeft",
	IndirectFire: "MouseRight",
	ShieldToggle: "Space"
}

const Configuration = {
	Ship: {
		Fighter: {
			T1: { MovementSpeed: 130, RotationSpeed: 1.5 },
			T2: { MovementSpeed: 150, RotationSpeed: 1.4 }
		},
		Gunship: {
			T1: { MovementSpeed: 100, RotationSpeed: 2.0 },
			T2: { MovementSpeed: 90, RotationSpeed: 2.1 }
		},
		Cruiser: {
			T1: { MovementSpeed: 70, RotationSpeed: 1.5 },
			T2: { MovementSpeed: 50, RotationSpeed: 1.3 }
		},
		Carrier: {}
	},
	Core: {
		T1: { Health: 100, Regen: 1, Radius:  5, Explosion: { Radius: 100, Damage: 10 } },
		T2: { Health: 200, Regen: 1, Radius: 10, Explosion: { Radius: 200, Damage: 20 } }
	},
	Gatling: {
		T1: { Health: 100, Regen: 1, Radius: 5, RotationSpeed: 1.5, Explosion: { Radius: 50, Damage: 10 } }
	},
	Howitzer: {},
	Sprayer: {},
	// G1 - Machine Gun
	// H1 - Howitzer
	// S1 - Sprayer
	// M1 - Missile Launcher (Geyser)
	// D1 - Drone Launcher (White Hole)
	MissileLauncher: {},
	Shell: {
		T1: {},
		T2: {}
	},
	Missile: {
		T1: {},
		T2: {}
	},
	Shield: {
		T1: {},
		T2: {}
	}
}

const Asset = {
	Direct: {
		Gatling: {
			Dash: "DG1-H1 Dash",
			Liner: "DG2-H1 Liner"
		},
		Howitzer: {
			Ravager: "DH2-M3 Ravager"
		},
		Sprayer: {}
	},
	Indirect: {
		MissileLauncher: {
			Paparazzi: "IM1-M2 Paparazzi"
		}
	},
	Special: {
		Shield: {}
	}
}

const Ship = {
	Moth: {
		MF1ADG2: "MF1A-DG2 Moth",
		MF1BIM2: "MF1B-IM2 Moth"
	},
	Skate: {
		MF2ADG5: "MF2A-DG5 Skate"
	},
	Pollen: {
		WG1ADG1: "WG1A-DG1 Pollen",
		WG1BIM1: "WG1B-IM1 Pollen"
	},
	Scorpion: {
		YG2ADG10: "YG2A-DG10 Scorpion",
		YG2BDG8DH2: "YG2B-DG8-DH2 Scorpion"
	},
	Scarab: {
		XC1ADG6: "XC1A-DG6 Scarab",
		XC1BDG4IM2: "XC1B-DG4-IM2 Scarab"
	},
	Wasp: {
		AC1ADG8: "AC1A-DG8 Wasp",
		AC1BDG6IM2: "AC1B-DG6-IM2 Wasp",
		AC1CDG4IM4: "AC1C-DG4-IM4 Wasp",
		AC1DDG2IM6: "AC1D-DG2-IM6 Wasp"
	}
}

// Unity3D-lik-ish Components
// -----------------------------------------------------------------

const Hook = {
	afterUniverseInstanciatesActor: Symbol("[Hook:Actor]: 'After a universe instanciates an actor'"),
	beforeUniverseAddsActor: Symbol("[Hook:Actor]: 'Before a universe adds an actor'"),
	beforeUniverseAddsTrait: Symbol("[Hook:Trait]: 'Before a universe adds a trait'"),
	afterUniverseAddsTrait: Symbol("[Hook:Trait]: 'After a universe adds a trait'"),
	afterUniverseAddsActor: Symbol("[Hook:Actor]: 'After a universe adds an actor'"),
	afterActorInstantiatesTrait: Symbol("[Hook:Trait]: 'After an actor instantiates a trait'"),
	beforeActorAddsTrait: Symbol("[Hook:Trait]: 'Before an actor adds a trait'"),
	afterActorAddsTrait: Symbol("[Hook:Trait]: 'After an actor adds a trait'"),
	afterUniverseUpdatesTrait: Symbol("[Hook:Trait]: 'After a universe updates a trait'"),
	beforeUniverseRemovesActor: Symbol("[Hook:Actor]: 'Before a universe removes an actor'"),
	beforeUniverseRemovesTrait: Symbol("[Hook:Trait]: 'Before a universe removes a trait'"),
	afterUniverseRemovesTrait: Symbol("[Hook:Trait]: 'After a universe removes a trait'"),
	afterUniverseRemovesActor: Symbol("[Hook:Actor]: 'After a universe removes an actor'")
}

class Universe {
	constructor() {
		this.actors = new Set()
		this.traits = new Set()
	}
	add(actorConstructor, ...actorParameters) {
		const actor = new actorConstructor(this)
		actor[Hook.afterUniverseInstanciatesActor](...actorParameters)
		actor[Hook.beforeUniverseAddsActor]()
		for (const trait of actor.traits) {
			trait[Hook.beforeUniverseAddsTrait]()
			this.traits.add(trait)
			trait[Hook.afterUniverseAddsTrait]()
		}
		this.actors.add(actor)
		actor[Hook.afterUniverseAddsActor]()
		return actor
	}
	remove(actor) {
		if (this.actors.has(actor)) {
			actor[Hook.beforeUniverseRemovesActor]()
			for (const trait of actor.traits) {
				trait[Hook.beforeUniverseRemovesTrait]()
				this.traits.delete(trait)
				trait[Hook.afterUniverseRemovesTrait]()
			}
			this.actors.delete(actor)
			actor[Hook.afterUniverseRemovesActor]()
		}
	}
	update() {
		for (const trait of this.traits) {
			trait[Hook.afterUniverseUpdatesTrait]
		}
	}
}

class Actor {
	constructor(universe) {
		this.universe = universe
		this.traits = new Map()
	}
	add(traitConstructor, ...traitParameters) {
		if (!this.traits.has(traitConstructor)) {
			const trait = new traitConstructor(this)
			trait[Hook.afterActorInstantiatesTrait](...traitParameters)
			trait[Hook.beforeActorAddsTrait]()
			this.traits.set(traitConstructor, trait)
			trait[Hook.afterActorAddsTrait]()
			return trait
		}
	}
	get(traitConstructor) {
		return this.traits.get(traitConstructor)
	}
	onInitialize() {}
	onAdding() {}
	onAdded() {}
	[Hook.afterUniverseInstanciatesActor]() { this.onInitialize(...arguments) }
	[Hook.beforeUniverseAddsActor]() { this.onAdding() }
	[Hook.afterUniverseAddsActor]() { this.onAdded() }
	[Hook.beforeUniverseRemovesActor]() {}
	[Hook.afterUniverseRemovesActor]() {}
}

class Trait {
	constructor(actor) {
		this.actor = actor
		this.universe = actor.universe
	}
	onInitialize() {}
	onAdding() {}
	onAdded() {}
	onUpdate() {}
	onRemoving() {}
	onRemoved() {}
	[Hook.afterActorInstantiatesTrait]() { this.onInitialize(...arguments) }
	[Hook.beforeActorAddsTrait]() {}
	[Hook.afterActorAddsTrait]() {}
	[Hook.beforeUniverseAddsTrait]() { this.onAdding() }
	[Hook.afterUniverseAddsTrait]() { this.onAdded() }
	[Hook.beforeUniverseRemovesTrait]() {}
	[Hook.afterUniverseRemovesTrait]() { this.onRemoved() }
	[Hook.afterUniverseUpdatesTrait]() {
		this.onUpdate()
		if (this.onRemoving()) {
			this.universe.remove(this.actor)
		}
	}
}

class Transform extends Trait {
	onInitialize(x, y, angle) {
		this.x = x
		this.y = y
		this.angle = angle
	}
}

class Ephemeral extends Trait {
	onInitialize(lifeTime) {
		this.lifeTime = lifeTime
		this.remainingLifeTime = lifeTime
	}
	onUpdate() {
		this.remainingLifeTime -= TIME_ENLAPSED
	}
	onRemoving() {
		return this.remainingLifeTime < 0
	}
}

class Destructible extends Trait {
	onInitialize(health, healthRegeneration = 0) {
		this.health = health
		this.maxHealth = health
		this.healthRegeneration = healthRegeneration
	}
	onUpdate() {
		if (this.health < this.maxHealth) {
			this.health += this.healthRegeneration * TIME_ENLAPSED
		}
	}
	onRemoving() {
		return this.health < 0
	}
}

class Movement extends Trait {
	onInitialize(speed = new Force(0, 0), acceleration = new Force(0, 0), friction = new Friction()) {
		this.transform = this.actor.get(Transform)
		this.speed = speed
		this.acceleration = acceleration
		this.friction = friction
	}
	onUpdate() {
		this.acceleration.drive(this.speed)
		this.friction.updateFrom(this.speed)
		this.friction.drive(this.speed)
		this.speed.drive(this.transform)
	}
}

class LinearMovement extends Trait {
	onInitialize(speedX, speedY) {
		this.transform = this.actor.get(Transform)
		this.speedX = speedX
		this.speedY = speedY
	}
	onUpdate() {
		this.transform.offset(this.speedX * TIME_ENLAPSED, this.speedY * TIME_ENLAPSED)
	}
}

class AngularLinearMovement extends LinearMovement {
	onInitialize(angle, speed) {
		super.onInitialize(cos(angle) * speed, sin(angle) * speed)
	}
}

class Collision = {
	onInitialize(collisionRadius, collisionDamage = 0) {
		this.collisionRadius = collisionRadius
		this.collisionDamage = collisionDamage
	}
	collidesWith(other) {
		return this.distanceToward(other) < this.collisionRadius + other.collisionRadius
	}
	collidesWithAny(others) {
		for (const other of others) {
			if (this.collidesWith(other)) {
				return true
			}
		}
		return false
	}
}

class TeamMember extends Trait {
	onInitialize(team = null) {
		this.team = team
	}
	isMateWith(other) {
		return other.team && this.team == other.team
	}
	findHostilesAmongst(others) {
		const result = new Set()
		for (const other of others) {
			if (!this.isMateWith(other)) {
				result.add(other)
			}
		}
		return result
	}
}

class Ship extends Actor {
	onInitialize(x, y, team) {
		this.add(Transform, x, y, PI / 3)
		this.add(Destructible, 500)
		this.add(Movement)
		this.add(TeamMember, team)
	}
}
const shipUniverse = new Universe()
shipUniverse.add(Ship, 125, 240, Team.BLUE)
// -----------------------------------------------------------------
// hookbeforeadd() { return this.onAdding() !== false }
// Poll.actorBehaviorTraits
// Poll.actorAddOnlyTraits
// Poll.actorRemoveOnlyTraits
// Poll.traitIsBehavior
// Poll.traitIsAddOnly
// Poll.traitIsRemoveOnly
// -----------------------------------------------------------------
class Actor {
	constructor(universe) {
		this.traits = new WeakSet()
	}
	add(traitConstructor, ...traitParameters) {
		let trait
		if (traitConstructor === Trait || traitConstructor.prototype instanceof Trait) {
			trait = new traitConstructor(this)
			trait.onInitialize(...traitParameters)
			this.traits.add(trait)
		} else {
			trait = new traitConstructor(...traitParameters)
		}
		this[traitConstructor.name] = trait
	}
	// Does it have a remove ? No, it doesn't.
}

class Ship extends Actor {
	onInitialize() {
		const rotation = rand(-PI, PI)
		this.add(Transform, 120, 120, rotation)
		this.add(Movement, rotation)
	}
}

class Transform {
	constructor(x = 0, y = 0, angle = 0) {
		this.x = x
		this.y = y
		this.angle = angle
	}
}

class Movement extends Trait {
	onInitialize(direction = 0) {
		const transform = this.actor.Transform
		this.direction = direction
		this.applyTo(transform)
	}
}

