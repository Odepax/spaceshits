Roadmap
-- // -----------------------------------------------------------------

[OK] Colliders
	[OK] Rectangle to rectangle
	[OK] Circle to circle
	[OK] Convex polygon to convex polygon
	[OK] Convex polygon to circle
	[OK] Include rotation
	[OK] Quick collision, based on rectangle/rectangle, but without rotation.
[OK] First graphics prototypes
[OK] First gameplay
[OK] Enemies
	[OK] Zombie cube
	[OK] Akimbo cube
	[OK] Cross-gun cube
	[OK] High-speed cube
	[OK] Splitting cube
	[OK] Factory cube
		[OK] Factory
		[OK] Crash crab
[OK] Weapons
	[OK] Energy Gauge
	[OK] Gatling
	[OK] Blaster
	[OK] Shotgun
[OK] Special capacities
	[OK] Energy Gauge
	[OK] Blink teleport
	[OK] Restauration
	[OK] Shield
[OK] Out-game interface
	[OK] Graphic chart
	[OK] Application's screens
		[OK] Main menu
		[OK] Settings
		[OK] In-game
			[OK] Pause
		[OK] Run lobby
		[OK] Defeat
		[OK] Victory
[  ] Leveling
	[  ] Per-level enemies builds
	[  ] Player upgrades
		> How to introduce choice that isn't simple calculation?
		> How to introduce choice that actually matter?
		[  ] Damage booster       > ++ damage
		[  ] Energy booster       > ++ energy capacity
		[  ] Hull booster         > ++ hp
		[  ] Auxiliary booster    > -- capacity cooldown
		[  ] Change weapon for the ...
		[  ] Change aux module for the ...
	[  ] Enemies upgrades
		[  ] Health
		[  ] Damage
		[  ] Speed
		[  ] Fire rate
		> Respond to player upgrades adequately.
	[  ] Display current run progress recap on application screens
		[  ] Run lobby
		[  ] Reward
		[  ] Defeat
		[  ] Victory
	[  ] Memory of player progress
		> How to backup the universe?
		> Case of a crash?
[  ] Better in-game HUD interface
	[  ] Player health
	[  ] Player weapon energy
	[  ] Player capacity energy
	[  ] Enemies health
		> Don't display if full?
		> Don't display if not touched for X seconds?
[  ] Lore
	[  ] Characters' dialogues
	[  ] Per-level scenarios
[  ] VFX
	[  ] Explosions
	[  ] Soundtrack
[  ] Optimization
	[  ] Math is going on?
	[  ] Resource loading
	[  ] Application screens as web components
[  ] More enemies
	[  ] Stationnary turret
	[  ] Crash crab with gun
	[  ] Bosses
[  ] More special capacities
	[  ] Berzerk
	[  ] Missile swarm
	[  ] Repelling shock wave
	[  ] Minefield drop
	[  ] Spiky hull
		> Passive, but still subject to energy cap?
	[  ] Whirlwind
		> Spiky hull's 'active' alternative.
		> Could have longer range.
[  ] More weapons
	[  ] Charged
	[  ] Laser

An Echo in the Space
-- // -----------------------------------------------------------------

- There exists one god that is everywhere and part of all: the universe; the universe won't come, nor stand to save anyone.
- The circumstances of their death will influence the value of their life.
- One cannot posibly enjoy anything they don't have full knowledge of.
- Three. Three? Weren't there four of them?
- Paradize and hell are not places they go, but space to fill in the memories of those who will outlive them.
- A suicide a day keeps the pressure away!
- Alone in the darkness, it shines...
- Snakes appear strait under a bent ruler...
- When the conquerors come in, the mountain perspires by the tiger's ass, and the dragon fucks the weasel.
- The fact we have the luxury to to complain about inanities is an indicator that we feel safe enough otherwise to do so.
- Could they have alleviated the part of the report about undergone physical sufferings?
- It likes to see their hope vanish...
- Life is not beautiful by nature, it becomes what they make of it.
- Life doesn't diverge from the existence of death, but rather death arises from the concept of life.
- Those who try to mine gold out of it, they shall receive nothing but dirt.
- It was ridiculous, it seems dangerous, it might become obvious...
- By the time of their disgrace, it shall awake...
- In its long agony, its knowledge is lost.
- It bites those who try to break its chains.
- They will be gnawed by what they demanded; they shall simply receive what they earned.
- When asked what it wanted to do once grown up, it answered that it wanted to do...
- They deplorably still can't accept the idea of infinity, clinging to the idea that all thing begins and ends...
- Yet being finite, they claim to be a fragment of its infinity; their logic is erroneous.
- To launch the program, launch the program by following the prefered program launching method of the platform.
- What they take for granted had once to be invented...

Levels Description
-- // -----------------------------------------------------------------

new Level([
	new DelayStage(2000),

	new DialogStage("An echo from space", "What they take for granted had once to be invented..."),
	new DialogStage("Jerico", "Did you hear that?"),
	new DialogStage("Alen", "Hear what?"),
	new DialogStage("Jerico", "That... You didn't hear some kinda strange, buzzing voice ?"),
	new DialogStage("Alen", "Mm... No... Should I?"),
	new DialogStage("Jerico", "M'key, now I'm going crazy..."),

	new DelayStage(3000),

	new DialogStage("Ship system", "* Radar beeps."),
	new DialogStage("Alen", "That, I hear! What do we have?"),
	new DialogStage("Jerico", "I... I'm not sure... The ship doesn't know it..."),
	new DialogStage("Alen", "Does it bite?"),

	new CombatStage([ ZombieCube ]),

	new DialogStage("Jerico", "The heck dude? You blew it up!"),
	new DialogStage("Alen", "Whell, yeah! Why not?"),
	new DialogStage("Jerico", "But we don't event know what this thing was...")
	new DialogStage("Jerico", "Ahr! ")

	new DelayStage(1000)
])

class Level {
	constructor(stages) {
		this.stages = stages
	}

	async execute(universe) {
		for (const stage of this.stages) {
			const outcome = await stage.execute()

			if (outcome.victory == false)
				return LevelOutcome.defeat()
		}

		return LevelOutcome.victory()
	}
}

class LevelOutcome {
	static victory() { return new LevelOutcome(true) }
	static defeat() { return new LevelOutcome(false) }

	constructor(victory) {
		this.victory = victory
	}
}

class DelayStage {
	constructor(time) {
		this.time = time
	}

	execute(universe) {
		return Promise.resolve(LevelOutcome.victory())
	}
}

class DialogStage {
	constructor(speaker, message) {
		this.speaker = speaker
		this.message = message
	}

	execute(universe) {
		return Promise.resolve(LevelOutcome.victory())
	}
}

class CombatStage {
	constructor(hostiles) {
		this.hostiles = hostiles
	}

	execute(universe) {
		return Promise.resolve(LevelOutcome.victory())
	}
}

Alternative Engine Design
-- // -----------------------------------------------------------------

const Random = {
	oneOf: (values) => values[parseInt(Math.random() * values.length)],
	in: (min, max) => Math.random() * (max - min) + min,
	sign: () => Random.oneOf([ -1, 1 ]),
	angle: () => Random.in(-PI, PI)
}

/*
traits must
	access other traits of the same link
	access game canvas
	access time
	access game settings
	access user controls (kb & mouse)
and so without using the universe as an old style data sharing singleton
*/

new Clock(
	new Universe([
		new Link([
			// new Transform(200, 200, 0)
		// ], [
			new WanderingRotation(Random.sign() * Random.in(PI / 8, PI / 2)),
			new LinearMovement(Random.in(200, 400), Random.angle()),
			new EdgeBouncing(renderCanvas)
		]),
		new Link([
			// new Transform(200, 200, 0)
		// ], [
			new MouseRotationController(new MouseObserver(renderCanvas, document)),
			new KeyboardMovementController(new KeyboardObserver(renderCanvas, document)),
			new EdgeBouncing(renderCanvas)
		])
	])
)

class Clock {
	constructor(universe = null) {
		universe && this.attach(universe)
		this.isRunning = false
		this.time = 0
		this.delta = 0
	}

	attach(universe) {
		// if (this.universe == null && universe.clock = null) {
			this.universe = universe
			this.universe.clock = this
		// } else {
			// throw [ "Clock#attach(universe) where Clock#universe or Universe#clock is already set.", this, universe ]
		// }
	}

	detachUniverse() {
		this.stop()
		this.universe.clock = null
		this.universe = null
	}

	start() {
		this.isRunning = true

		requestAnimationFrame(time => {
			this.delta = time * MILLI_SECONDS - this.time
			this.time = time * MILLI_SECONDS

			requestAnimationFrame(time => this.step(time))
		})
	}

	step(time) {
		this.delta = time * MILLI_SECONDS - this.time
		this.time = time * MILLI_SECONDS

		this.universe.step()

		if (this.isRunning) {
			requestAnimationFrame(time => this.step(time))
		}
	}

	stop() {
		this.isRunning = false
	}
}

class Universe {
	constructor(links = []) {
		this.clock = null
		this.links = new Set()

		for (const link of links) {
			this.attach(link)
		}
	}

	attach(link) {
		// if (link.universe == null) {
			link.universe = this
			this.links.add(link)
			link.onAttach()
		// } else {
			// throw [ "Universe#attach(link) where Link#universe is already set.", this, link ]
		// }
	}

	detach(link) {
		// if (link.universe == this && this.links.has(link)) {
			link.onDetach()
			this.links.delete(link)
			link.universe = null
		// } else {
			// throw [ "Universe#detach(link) where Link#universe does not correspond.", this, link ]
		// }
	}

	step() {
		for (const link of this.links) {
			link.onStep()

			if(link.shouldDetach) {
				this.detach(link)
			}
		}
	}
}

class Link {
	constructor(traits = []) {
		this.universe = null
		this.traits = new Set()
		this.shouldDetach = false

		for (const trait of traits) {
			this.attach(trait)
		}
	}

	get time() { return this.universe.clock.time }
	get delta() { return this.universe.clock.delta }

	attach(trait, alias = trait.constructor.name) {
		// if (trait.link == null) {
			trait.link = this
			this.traits.add(trait)
			this[alias] = trait
		// } else {
			// throw [ "Link#attach(trait) where Trait#link is already set.", this, trait ]
		// }
	}

	onAttach() { for (const trait of this.traits) trait.onAttach() }
	onDetach() { for (const trait of this.traits) trait.onDetach() }

	onStep() {
		for (const trait of this.traits) {
			trait.onStep()

			if (trait.shouldDetach) {
				this.shouldDetach = true
				break;
			}
		}
	}
}

class Trait {
	constructor() {
		this.link = null
		this.shouldDetach = false
	}

	onAttach() {}
	onStep() {}
	onDetach() {}
}

...

new Universe(
	new Clock(),
	[
		new Player(),
		new ZombieCube()
	]
)

-- VS --

new Clock(
	new Universe([
		new Player(),
		new ZombieCube()
	])
)
