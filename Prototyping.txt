// TODO
// ----
// [x] Scaling bug => scale up the ship.
// [x] Rotate turrets with ship.
// [x] Mv force transmission from ship to bullets. => TECH DEBT
// [x] Acceleration / max speed bug.
// [x] Fix teams requirements.
// [x] Fix colliders requirements.
// [x] Turret slot redesign.
// [x] Extract player controller to separate keyboard controller.
// [x] Create player rotative mouse controller.
// [ ] Create AI controllers.
// [ ] Implement relative camera.
// [ ] Constrain angle to arc > 180deg bug.

const Settings = {
	ShipController: {
		Keyboard: {
			Forward: "KeyW",
			Backward: "KeyS",
			RotateLeft: "KeyA",
			RotateRight: "KeyD",
			Left: "KeyQ",
			Right: "KeyE"
		},
		RotatingMouse: {
			Forward: "KeyW",
			Backward: "KeyS",
			Left: "KeyA",
			Right: "KeyD"
		}
	},
	DirectFire: "MouseLeft",
	IndirectFire: "MouseRight",
	ShieldToggle: "Space"
}

const Configuration = {
	Ship: {
		Fighter: {
			T1: { MovementSpeed: 130, RotationSpeed: 1.5 },
			T2: { MovementSpeed: 150, RotationSpeed: 1.4 }
		},
		Gunship: {
			T1: { MovementSpeed: 100, RotationSpeed: 2.0 },
			T2: { MovementSpeed: 90, RotationSpeed: 2.1 }
		},
		Cruiser: {
			T1: { MovementSpeed: 70, RotationSpeed: 1.5 },
			T2: { MovementSpeed: 50, RotationSpeed: 1.3 }
		},
		Carrier: {}
	},
	Core: {
		T1: { Health: 100, Regen: 1, Radius:  5, Explosion: { Radius: 100, Damage: 10 } },
		T2: { Health: 200, Regen: 1, Radius: 10, Explosion: { Radius: 200, Damage: 20 } }
	},
	Gatling: {
		T1: { Health: 100, Regen: 1, Radius: 5, RotationSpeed: 1.5, Explosion: { Radius: 50, Damage: 10 } }
	},
	Howitzer: {},
	Sprayer: {},
	// G1 - Machine Gun
	// H1 - Howitzer
	// S1 - Sprayer
	// M1 - Missile Launcher (Geyser)
	// D1 - Drone Launcher (White Hole)
	MissileLauncher: {},
	Shell: {
		T1: {},
		T2: {}
	},
	Missile: {
		T1: {},
		T2: {}
	},
	Shield: {
		T1: {},
		T2: {}
	}
}

const Asset = {
	Direct: {
		Gatling: {
			Dash: "DG1-H1 Dash",
			Liner: "DG2-H1 Liner"
		},
		Howitzer: {
			Ravager: "DH2-M3 Ravager"
		},
		Sprayer: {}
	},
	Indirect: {
		MissileLauncher: {
			Paparazzi: "IM1-M2 Paparazzi"
		}
	},
	Special: {
		Shield: {}
	}
}

const Ship = {
	Moth: {
		MF1ADG2: "MF1A-DG2 Moth",
		MF1BIM2: "MF1B-IM2 Moth"
	},
	Skate: {
		MF2ADG5: "MF2A-DG5 Skate"
	},
	Pollen: {
		WG1ADG1: "WG1A-DG1 Pollen",
		WG1BIM1: "WG1B-IM1 Pollen"
	},
	Scorpion: {
		YG2ADG10: "YG2A-DG10 Scorpion",
		YG2BDG8DH2: "YG2B-DG8-DH2 Scorpion"
	},
	Scarab: {
		XC1ADG6: "XC1A-DG6 Scarab",
		XC1BDG4IM2: "XC1B-DG4-IM2 Scarab"
	},
	Wasp: {
		AC1ADG8: "AC1A-DG8 Wasp",
		AC1BDG6IM2: "AC1B-DG6-IM2 Wasp",
		AC1CDG4IM4: "AC1C-DG4-IM4 Wasp",
		AC1DDG2IM6: "AC1D-DG2-IM6 Wasp"
	}
}

// GIVEN UP :: Unity3D-like Components
// -----------------------------------------------------------------

class Trait {
	constructor(options) {
		this.options = options
		this.actor = null;
	}

	initialize() {}

	require(traitType) {
		const trait = new traitType()

		this.actor.attach(trait)

		trait.initialize() // TODO prove that it doesn't initialize two times (i.e. here and in Actor#initialize@for)
	}
}

class Actor {
	constructor() {
		this.traits = new Map()
	}

	attach(trait) {
		if (!this.traits.has(trait.constructor)) {
			this.traits.set(trait.constructor, trait)

			trait.actor = this
		}
	}

	initialize() {
		for (const trait of this.traits.values()) {
			trait.initialize()
		}
	}
}

class Universe {
}

// -----------------------------------------------------------------

const Lifecycle = {
	initialize: Symbol("@@initialize"),
	add: Symbol("@@add"),
	update: Symbol("@@update"),
	remove: Symbol("@@remove")
}

const second = 1000
const seconds = 1000

class Explosion extends Container {
	[Lifecycle.initialize](context, { x = 0, y = 0, radius = 0 } = {}) {
		this.add(Transform, { x, y })
		this.add(Collision, { radius })
		this.add(ExplosionRender)
	}
}

context.new(Explosion, { x: 200, y: 200, radius: 90 })

class Transform extends Component {
	[Lifecycle.initialize](context, { x = 0, y = 0, a = 0 } = {}) {
		this.x = x
		this.y = y
		this.a = a
	}
}

class Ephemeral extends Component {
	[Lifecycle.initialize](context, { ttl = 1 * second } = {}) {
		this.lifeTime = ttl
		this.remainingTime = ttl
	}

	[Lifecycle.update](context) {
		this.remainingTime -= context.timeEnlapsed

		if (this.remainingTime <= 0) {
			context.remove(this)
		}
	}
}

class ExplosionRender extends Component {
	[Lifecycle.initialize](context) {
		this.require(Transform)
		this.require(Ephemeral)
		this.require(Collision)
	}

	[Lifecycle.add](context) {
		this.ephemeral = this.container.components.get(Ephemeral)
		this.transform = this.container.components.get(Transform)
		this.collision = this.container.components.get(Collision)
	}

	[Lifecycle.update](context) {
		context.graphics.drawCircle({
			x: this.transform.x,
			y: this.transform.y,
			r: this.collision.radius,
			fill: Color.yellow,
			opacity: 1 - this.ephemeral.remainingTime / this.ephemeral.lifeTime
		})
	}
}

class Container {
	constructor() {
		this.components = new Map()
	}

	add(componentType, componentConfiguration) {
		this.components.set(componentType, componentConfiguration)
	}

	[Lifecycle.add](context) {
		for (const [ componentType, componentConfiguration ] of this.components) {
			this.resolve(new componentType())
		}

		for (const component of this.components) {
			context.add(component)
		}
	}

	resolve(component) {
		for (const dependencyType of component.dependencies) {
			if (!this.components.has(dependencyType)) {
				const dependency = new dependencyType()

				this.resolve(dependency)
			}
		}

		component.container = this

		this.components.set(component.constructor, component)
	}
}

class Component {
	constructor() {
		this.container = null
		this.dependencies = new Set() // Set<Type<T>>
	}
	require(dependencyType) {
		this.dependencies.add(dependencyType)
	}
	attachToContainer(container) {
		this.container = container
	}
	detachFromContainer() {
		this.container = null
	}

	[Lifecycle.initialize](context) {}
	[Lifecycle.add](context) {}
	[Lifecycle.update](context) {}
	[Lifecycle.remove](context) {}
}
